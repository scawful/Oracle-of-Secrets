#!/usr/bin/env python3
"""
Generate ASM include files from the canonical location_registry.json.

This ensures the JSON is the single source of truth and the ASM files
are generated from it, not the other way around.

Usage:
    python3 scripts/generate_location_asm.py

Output:
    Data/Generated/dungeon_location_names.asm
"""

import json
import os
import sys
from pathlib import Path

SCRIPT_DIR = Path(__file__).parent
PROJECT_ROOT = SCRIPT_DIR.parent
REGISTRY_PATH = PROJECT_ROOT / "Data" / "location_registry.json"
OUTPUT_DIR = PROJECT_ROOT / "Data" / "Generated"


def pad_name(name: str, length: int = 16) -> str:
    """Pad/truncate name to fixed length with underscores."""
    name = name.upper().replace(" ", "_").replace("'", "")
    if len(name) > length:
        return name[:length]
    return name + "_" * (length - len(name))


def generate_dungeon_names_asm(registry: dict) -> str:
    """Generate the DungeonLocationNames table from registry."""
    lines = [
        "; Auto-generated from Data/location_registry.json",
        "; DO NOT EDIT MANUALLY - edit location_registry.json instead",
        "; Generated by scripts/generate_location_asm.py",
        "",
        "DungeonLocationNames:",
    ]

    # Build room name lookup (0x00 - 0x127 = 296 rooms)
    room_names = {}

    # Process dungeons
    for dungeon_key, dungeon in registry.get("dungeons", {}).items():
        dungeon_name = dungeon["name"]
        for room_hex, room_data in dungeon.get("rooms", {}).items():
            room_id = int(room_hex, 16)
            room_names[room_id] = dungeon_name

    # Process shrines
    for shrine_key, shrine in registry.get("shrines", {}).items():
        shrine_name = shrine["name"]
        for room_hex in shrine.get("rooms", []):
            room_id = int(room_hex, 16)
            room_names[room_id] = shrine_name

    # Process fortress
    for fort_key, fort in registry.get("fortress", {}).items():
        fort_name = fort["name"]
        for room_hex in fort.get("rooms", []):
            room_id = int(room_hex, 16)
            room_names[room_id] = fort_name

    # Process caves
    for cave_key, cave in registry.get("caves", {}).items():
        cave_name = cave["name"]
        for room_hex in cave.get("rooms", []):
            room_id = int(room_hex, 16)
            room_names[room_id] = cave_name

    # Process special areas
    for special_key, special in registry.get("special", {}).items():
        special_name = special["name"]
        for room_hex in special.get("rooms", []):
            room_id = int(room_hex, 16)
            room_names[room_id] = special_name

    # Process houses
    for house_key, house in registry.get("houses", {}).items():
        house_name = house["name"]
        room_hex = house.get("room", "")
        if room_hex:
            room_id = int(room_hex, 16)
            room_names[room_id] = house_name

    # Process fairy fountains
    for fairy_key, fairy in registry.get("fairy_fountains", {}).items():
        fairy_name = fairy["name"]
        room_hex = fairy.get("room", "")
        if room_hex:
            room_id = int(room_hex, 16)
            room_names[room_id] = fairy_name

    # Generate table (16 entries per line)
    for row_start in range(0, 0x128, 16):
        row_names = []
        for i in range(16):
            room_id = row_start + i
            if room_id >= 0x128:
                break
            name = room_names.get(room_id, "")
            row_names.append(f'"{pad_name(name)}"')

        if row_names:
            comment = f"; {row_start:02X}-{row_start + len(row_names) - 1:02X}"
            lines.append(f"  dw {', '.join(row_names)} {comment}")

    return "\n".join(lines)


def generate_overworld_names_asm(registry: dict) -> str:
    """Generate the OverworldLocationNames tables from registry."""
    lines = [
        "; Auto-generated from Data/location_registry.json",
        "; DO NOT EDIT MANUALLY - edit location_registry.json instead",
        "; Generated by scripts/generate_location_asm.py",
        "",
    ]

    # Light World
    lines.append("OverworldLocationNames:")
    light_world = registry.get("overworld_areas", {}).get("light_world", {})
    for i in range(0x40):
        hex_key = f"0x{i:02X}"
        name = light_world.get(hex_key, "")
        lines.append(f'  dw "{pad_name(name)}" ; {i:02X}')

    lines.append("")

    # Dark World
    lines.append("DarkWorldLocationNames:")
    dark_world = registry.get("overworld_areas", {}).get("dark_world", {})
    for i in range(0x40):
        hex_key = f"0x{i:02X}"
        name = dark_world.get(hex_key, "")
        lines.append(f'  dw "{pad_name(name)}" ; {i:02X}')

    return "\n".join(lines)


def main():
    # Load registry
    if not REGISTRY_PATH.exists():
        print(f"Error: Registry not found at {REGISTRY_PATH}")
        sys.exit(1)

    with open(REGISTRY_PATH) as f:
        registry = json.load(f)

    # Create output directory
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

    # Generate dungeon names
    dungeon_asm = generate_dungeon_names_asm(registry)
    dungeon_path = OUTPUT_DIR / "dungeon_location_names.asm"
    with open(dungeon_path, "w") as f:
        f.write(dungeon_asm)
    print(f"Generated: {dungeon_path}")

    # Generate overworld names
    overworld_asm = generate_overworld_names_asm(registry)
    overworld_path = OUTPUT_DIR / "overworld_location_names.asm"
    with open(overworld_path, "w") as f:
        f.write(overworld_asm)
    print(f"Generated: {overworld_path}")

    # Print summary
    dungeons = registry.get("dungeons", {})
    total_dungeon_rooms = sum(len(d.get("rooms", {})) for d in dungeons.values())
    print(f"\nRegistry Summary:")
    print(f"  Dungeons: {len(dungeons)}")
    print(f"  Total dungeon rooms: {total_dungeon_rooms}")
    print(f"  Shrines: {len(registry.get('shrines', {}))}")
    print(f"  Caves: {len(registry.get('caves', {}))}")
    print(f"  Houses: {len(registry.get('houses', {}))}")


if __name__ == "__main__":
    main()
