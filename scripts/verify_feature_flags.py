#!/usr/bin/env python3
"""Verify feature-flag definitions are standardized and consistent.

Rules:
- All feature flags are named !ENABLE_*.
- Defaults live in Util/macros.asm.
- Overrides live in Config/feature_flags.asm (typically generated by scripts/set_feature_flags.py).
- No other .asm file should assign to !ENABLE_* (read-only use is fine).

Exit code:
- 0 if OK
- 1 if any violations were found
"""

from __future__ import annotations

import argparse
import re
import sys
from dataclasses import dataclass
from pathlib import Path


DEFINE_ASSIGN_RE = re.compile(
    r"^\s*!([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(\$[0-9A-Fa-f]+|0x[0-9A-Fa-f]+|\d+)\b"
)

SKIP_DIRS = {
    ".git",
    ".context",
    ".claude",
    "Roms",
    "Docs",
    "build",
    "bin",
    "obj",
    "Tools",
    "tools",
    "tests",
    "node_modules",
}


@dataclass(frozen=True)
class DefineSite:
    file: Path
    line_no: int
    value: int


def _parse_int(token: str) -> int:
    token = token.strip()
    if token.startswith("$"):
        token = "0x" + token[1:]
    # Avoid Python's base=0 ambiguity with leading zeros (e.g. "02").
    if token.isdigit():
        return int(token, 10)
    return int(token, 0)


def _iter_define_assignments(path: Path) -> list[tuple[str, int, int]]:
    out: list[tuple[str, int, int]] = []
    for idx, line in enumerate(path.read_text(encoding="utf-8", errors="ignore").splitlines(), start=1):
        m = DEFINE_ASSIGN_RE.match(line)
        if not m:
            continue
        name = m.group(1).strip()
        value = _parse_int(m.group(2))
        out.append((name, value, idx))
    return out


def _discover_features(macros_path: Path) -> tuple[list[str], dict[str, DefineSite]]:
    features: list[str] = []
    sites: dict[str, DefineSite] = {}
    for name, value, line_no in _iter_define_assignments(macros_path):
        if not name.startswith("ENABLE_"):
            continue
        features.append(name)
        if name in sites:
            # Keep first site and let the verifier flag duplicates.
            continue
        sites[name] = DefineSite(file=macros_path, line_no=line_no, value=value)
    features = sorted(set(features))
    return features, sites


def _parse_feature_overrides(path: Path) -> dict[str, DefineSite]:
    overrides: dict[str, DefineSite] = {}
    for name, value, line_no in _iter_define_assignments(path):
        if not name.startswith("ENABLE_"):
            continue
        if name in overrides:
            continue
        overrides[name] = DefineSite(file=path, line_no=line_no, value=value)
    return overrides


def _should_skip(path: Path) -> bool:
    return any(part in SKIP_DIRS for part in path.parts)


def main() -> int:
    parser = argparse.ArgumentParser(description="Verify feature flag definitions and overrides")
    parser.add_argument("--root", type=Path, default=Path("."), help="Repo root (default: .)")
    parser.add_argument("--strict", action="store_true", help="Fail if Config/feature_flags.asm is missing")
    args = parser.parse_args()

    root = args.root.resolve()
    macros_path = root / "Util" / "macros.asm"
    overrides_path = root / "Config" / "feature_flags.asm"

    errors: list[str] = []
    warnings: list[str] = []

    if not macros_path.exists():
        errors.append(f"Missing macros file: {macros_path}")
        print("\n".join(errors), file=sys.stderr)
        return 1

    features, default_sites = _discover_features(macros_path)

    if not overrides_path.exists():
        msg = f"Missing feature override file: {overrides_path}"
        if args.strict:
            errors.append(msg)
        else:
            warnings.append(msg)
        overrides: dict[str, DefineSite] = {}
    else:
        overrides = _parse_feature_overrides(overrides_path)

    # Validate default and override values are boolean-ish.
    for name, site in sorted(default_sites.items()):
        if site.value not in (0, 1):
            errors.append(f"{site.file}:{site.line_no}: !{name} default must be 0/1 (got {site.value})")
    for name, site in sorted(overrides.items()):
        if site.value not in (0, 1):
            errors.append(f"{site.file}:{site.line_no}: !{name} override must be 0/1 (got {site.value})")

    # Ensure overrides don't define unknown features.
    known = set(features)
    for name, site in sorted(overrides.items()):
        if name not in known:
            errors.append(f"{site.file}:{site.line_no}: !{name} not defined in {macros_path}")

    # Ensure the override file covers all known features (keeps it self-documenting).
    missing = sorted(known - set(overrides.keys()))
    if overrides_path.exists() and missing:
        errors.append(
            f"{overrides_path}: missing overrides for {len(missing)} feature(s): {', '.join(missing)}"
        )

    # Ensure no other .asm assigns !ENABLE_* (to keep flags centralized).
    allowed = {macros_path.resolve(), overrides_path.resolve()}
    for asm_path in root.rglob("*.asm"):
        if _should_skip(asm_path):
            continue
        resolved = asm_path.resolve()
        if resolved in allowed:
            continue
        for name, value, line_no in _iter_define_assignments(asm_path):
            if not name.startswith("ENABLE_"):
                continue
            errors.append(
                f"{asm_path}:{line_no}: !{name} assignment must live in Util/macros.asm "
                f"(default) or Config/feature_flags.asm (override), not here"
            )

    if warnings:
        for w in warnings:
            print(f"[WARN] {w}", file=sys.stderr)

    if errors:
        for e in errors:
            print(f"[ERR] {e}", file=sys.stderr)
        return 1

    print(f"Feature flags OK ({len(features)} discovered, {len(overrides)} overrides).")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
