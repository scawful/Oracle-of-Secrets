"""
Report generators for Oracle Debugger.

Generates human-readable (Markdown) and machine-readable (JSON) reports
from debugging sessions.
"""

import json
from datetime import datetime
from pathlib import Path
from typing import Optional

from .session import DebugSession, Detection, AnalysisResult


class MarkdownReporter:
    """Generates Markdown bug reports from debug sessions."""

    def __init__(self, output_dir: Optional[Path] = None):
        """
        Initialize reporter.

        Args:
            output_dir: Directory for report output (default: ./crash_reports)
        """
        self.output_dir = output_dir or Path("crash_reports")

    def generate(self, session: DebugSession) -> str:
        """
        Generate a Markdown report from a debug session.

        Args:
            session: Debug session with collected data

        Returns:
            Markdown-formatted report string
        """
        lines = []

        # Header
        lines.append(f"# Bug Report: {session.session_id}")
        lines.append("")
        lines.append(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"**Session Duration:** {session.duration():.1f}s")
        if session.rom_path:
            lines.append(f"**ROM:** {session.rom_path}")
        if session.tags:
            lines.append(f"**Tags:** {', '.join(session.tags)}")
        lines.append("")

        # Summary
        lines.append("## Summary")
        lines.append("")
        detection_summary = session.get_detection_summary()
        if detection_summary:
            lines.append(f"Detected {len(session.detections)} issue(s):")
            for pattern, count in detection_summary.items():
                lines.append(f"- **{pattern}**: {count}")
        else:
            lines.append("No issues detected during this session.")
        lines.append("")

        # Detections
        if session.detections:
            lines.append("## Detections")
            lines.append("")
            for i, detection in enumerate(session.detections, 1):
                lines.extend(self._format_detection(i, detection))
            lines.append("")

        # Traces
        if session.traces:
            lines.append("## Execution Traces")
            lines.append("")
            for i, trace in enumerate(session.traces, 1):
                lines.append(f"### Trace {i}")
                lines.append(f"- **Frames captured:** {len(trace.frames)}")
                lines.append(f"- **Symbols resolved:** {'Yes' if trace.symbols_resolved else 'No'}")
                lines.append("")
                if trace.frames:
                    lines.extend(self._format_trace_table(trace.frames[-20:]))
                lines.append("")

        # States
        if session.states:
            lines.append("## Captured States")
            lines.append("")
            for i, state in enumerate(session.states, 1):
                lines.append(f"### State {i}")
                if state.state_path:
                    lines.append(f"- **Path:** `{state.state_path}`")
                if state.state_slot is not None:
                    lines.append(f"- **Slot:** {state.state_slot}")
                if state.cpu_state:
                    lines.append("- **CPU State:**")
                    lines.append("```json")
                    lines.append(json.dumps(state.cpu_state, indent=2))
                    lines.append("```")
                lines.append("")

        # Analyses
        if session.analyses:
            lines.append("## Expert Analysis")
            lines.append("")
            for i, analysis in enumerate(session.analyses, 1):
                lines.extend(self._format_analysis(i, analysis))
            lines.append("")

        # Notes
        if session.notes:
            lines.append("## Session Notes")
            lines.append("")
            for note in session.notes:
                lines.append(f"- {note}")
            lines.append("")

        # Footer
        lines.append("---")
        lines.append("*Generated by Oracle Debugger*")

        return "\n".join(lines)

    def _format_detection(self, index: int, detection: Detection) -> list[str]:
        """Format a single detection."""
        lines = [
            f"### Detection {index}: {detection.pattern or detection.detection_type}",
            "",
            f"- **Type:** {detection.detection_type}",
            f"- **Pattern:** {detection.pattern or 'N/A'}",
            f"- **Frame:** {detection.frame_number}",
            f"- **Game Mode:** `${detection.game_mode:02X}`",
            f"- **Submodule:** `${detection.submodule:02X}`",
            f"- **Link Position:** ({detection.link_position[0]}, {detection.link_position[1]}, {detection.link_position[2]})",
        ]

        if detection.description:
            lines.append(f"- **Description:** {detection.description}")

        lines.append("")
        return lines

    def _format_trace_table(self, frames: list[dict]) -> list[str]:
        """Format trace frames as a Markdown table."""
        lines = [
            "| Frame | PC | Instruction | A | X | Y | P |",
            "|-------|------|-------------|-----|-----|-----|-----|",
        ]

        for frame in frames:
            pc = frame.get("pc", 0)
            symbol = frame.get("symbol", "")
            pc_str = f"${pc:06X}" + (f" ({symbol})" if symbol else "")

            lines.append(
                f"| {frame.get('frame', 0)} | "
                f"{pc_str} | "
                f"{frame.get('instruction', '???')} | "
                f"${frame.get('a', 0):04X} | "
                f"${frame.get('x', 0):04X} | "
                f"${frame.get('y', 0):04X} | "
                f"${frame.get('p', 0):02X} |"
            )

        return lines

    def _format_analysis(self, index: int, analysis: AnalysisResult) -> list[str]:
        """Format an analysis result."""
        lines = [
            f"### Analysis {index} ({analysis.expert})",
            "",
            f"**Confidence:** {analysis.confidence:.0%}",
            "",
            "**Response:**",
            "",
        ]

        # Wrap response in blockquote
        for line in analysis.response.split("\n"):
            lines.append(f"> {line}")
        lines.append("")

        if analysis.suggested_fix:
            lines.append("**Suggested Fix:**")
            lines.append("```asm")
            lines.append(analysis.suggested_fix)
            lines.append("```")
            lines.append("")

        if analysis.related_files:
            lines.append("**Related Files:**")
            for f in analysis.related_files:
                lines.append(f"- `{f}`")
            lines.append("")

        return lines

    def save(self, session: DebugSession) -> Path:
        """
        Generate and save report to file.

        Args:
            session: Debug session

        Returns:
            Path to saved report
        """
        self.output_dir.mkdir(parents=True, exist_ok=True)
        report_path = self.output_dir / f"{session.session_id}.md"

        content = self.generate(session)
        report_path.write_text(content)

        return report_path


class JSONReporter:
    """Generates JSON reports from debug sessions."""

    def __init__(self, output_dir: Optional[Path] = None):
        """
        Initialize reporter.

        Args:
            output_dir: Directory for report output (default: ./crash_reports)
        """
        self.output_dir = output_dir or Path("crash_reports")

    def generate(self, session: DebugSession) -> dict:
        """
        Generate a JSON report from a debug session.

        Args:
            session: Debug session with collected data

        Returns:
            Dictionary suitable for JSON serialization
        """
        return {
            "version": 1,
            "generated_at": datetime.now().isoformat(),
            "session": session.to_dict(),
            "summary": {
                "detection_count": len(session.detections),
                "detection_types": session.get_detection_summary(),
                "trace_count": len(session.traces),
                "state_count": len(session.states),
                "analysis_count": len(session.analyses),
                "duration_seconds": session.duration(),
            },
        }

    def save(self, session: DebugSession) -> Path:
        """
        Generate and save report to file.

        Args:
            session: Debug session

        Returns:
            Path to saved report
        """
        self.output_dir.mkdir(parents=True, exist_ok=True)
        report_path = self.output_dir / f"{session.session_id}-report.json"

        content = self.generate(session)
        with open(report_path, "w") as f:
            json.dump(content, f, indent=2)

        return report_path


class RegressionTestGenerator:
    """Generates regression test definitions from detections."""

    def __init__(self, tests_dir: Optional[Path] = None):
        """
        Initialize generator.

        Args:
            tests_dir: Directory for test output (default: ./tests/regression)
        """
        self.tests_dir = tests_dir or Path("tests/regression")

    def generate_test(
        self,
        detection: Detection,
        state_path: str,
        input_sequence: Optional[list[dict]] = None,
    ) -> dict:
        """
        Generate a regression test definition from a detection.

        Args:
            detection: Detection that triggered the test
            state_path: Path to save state that reproduces the bug
            input_sequence: Optional input sequence to reproduce

        Returns:
            Test definition dictionary
        """
        test_id = f"{detection.pattern or detection.detection_type}_{detection.detection_id}"

        test_def = {
            "name": f"Regression: {detection.pattern or detection.detection_type}",
            "description": detection.description or f"Auto-generated regression test for {detection.pattern}",
            "version": "1.0",
            "saveState": {
                "path": state_path,
                "waitSeconds": 5,
            },
            "preconditions": {
                "$7E0010": {
                    "equals": detection.game_mode,
                    "desc": "Game mode at detection time"
                },
            },
            "steps": [],
            "onFailure": {
                "expert": "farore",
                "context": f"Regression test for {detection.pattern} failed. "
                          f"Original detection: {detection.description}"
            },
            "tags": [
                "regression",
                "auto-generated",
                detection.pattern or detection.detection_type,
            ],
            "metadata": {
                "original_detection": detection.to_dict(),
                "generated_at": datetime.now().isoformat(),
            },
        }

        # Add input sequence if provided
        if input_sequence:
            for inp in input_sequence:
                test_def["steps"].append({
                    "type": "press",
                    "button": inp.get("button", "A"),
                    "frames": inp.get("frames", 5),
                })
                if inp.get("wait"):
                    test_def["steps"].append({
                        "type": "wait",
                        "seconds": inp["wait"],
                    })

        # Add assertions based on detection type
        if detection.pattern == "B007":  # Y-overflow
            test_def["steps"].append({
                "type": "wait",
                "seconds": 2,
            })
            test_def["steps"].append({
                "type": "assert",
                "address": "$7E0020",
                "condition": "less_than",
                "value": 60000,
                "description": "Link Y position should not overflow",
            })
        elif detection.pattern == "B009":  # Mode reset
            test_def["steps"].append({
                "type": "wait",
                "seconds": 2,
            })
            test_def["steps"].append({
                "type": "assert",
                "address": "$7E0010",
                "not_equals": 0,
                "description": "Game mode should not reset to 0",
            })
        elif detection.pattern == "INIDISP":  # Black screen
            test_def["steps"].append({
                "type": "wait",
                "seconds": 3,
            })
            test_def["steps"].append({
                "type": "assert",
                "address": "$7E0010",
                "not_equals": 0x80,
                "description": "INIDISP should not be stuck at 0x80",
            })

        return test_def

    def save_test(
        self,
        detection: Detection,
        state_path: str,
        input_sequence: Optional[list[dict]] = None,
    ) -> Path:
        """
        Generate and save a regression test.

        Args:
            detection: Detection that triggered the test
            state_path: Path to save state
            input_sequence: Optional input sequence

        Returns:
            Path to saved test file
        """
        self.tests_dir.mkdir(parents=True, exist_ok=True)

        test_def = self.generate_test(detection, state_path, input_sequence)
        test_id = f"{detection.pattern or detection.detection_type}_{detection.detection_id}"
        test_path = self.tests_dir / f"{test_id}.json"

        with open(test_path, "w") as f:
            json.dump(test_def, f, indent=2)

        return test_path
