#!/usr/bin/env python3
"""
Export a portable `.yazeproj` bundle for yaze (macOS + iOS).

This is the "seamless Mac <-> iPad" file format:
  - A `.yazeproj` is a directory package that can live in iCloud Drive.
  - It contains a ROM plus a filtered snapshot of the Oracle-of-Secrets repo.
  - yaze can open the bundle root directly.

Bundle layout (compatible with yaze core + iOS document browser):
  <Name>.yazeproj/
    project.yaze        # yaze project config (paths relative to bundle root)
    manifest.json       # iOS-friendly metadata (optional for core)
    rom                # ROM binary (no extension)
    project/           # Oracle-of-Secrets snapshot (hack_manifest + Docs/Dev/Planning)
    backups/           # per-bundle backups (optional)
    output/            # per-bundle build output (optional)
"""

from __future__ import annotations

import argparse
import datetime as _dt
import hashlib
import json
import os
import platform
import shutil
import subprocess
import sys
from pathlib import Path


def find_repo_root() -> Path:
    p = Path(__file__).resolve().parent.parent
    if (p / "CLAUDE.md").exists():
        return p
    return Path.cwd().resolve()


def sha1_file(path: Path) -> str:
    h = hashlib.sha1()
    with path.open("rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()


def iso8601_now_utc() -> str:
    return _dt.datetime.now(tz=_dt.timezone.utc).isoformat(timespec="seconds")


def should_skip(rel: Path) -> bool:
    """
    Decide whether to exclude a path from the bundled project snapshot.
    `rel` is a path relative to the Oracle-of-Secrets repo root.
    """
    parts = set(rel.parts)

    # Repo-internal state and caches (not useful on iOS; often huge/noisy).
    if parts & {
        ".git",
        ".agent",
        ".cache",
        ".claude",
        ".context",
        ".cursor",
        ".genkit",
        ".gemini",
        ".pytest_cache",
        ".vscode",
        "build",
        "evaluations",
        "scratchpad",
    }:
        return True

    # ROM binaries and archives: bundle has its own `rom` file.
    if rel.parts and rel.parts[0] == "Roms":
        return True

    # Visual diffs/screenshots are large and not needed for editing.
    if rel.parts and rel.parts[0] == "tests":
        if len(rel.parts) >= 2 and rel.parts[1] in {
            "screenshots",
            "baselines",
            "baseline",
            "current",
            "diffs",
        }:
            return True

    # OS noise
    if rel.name in {".DS_Store", "Thumbs.db"}:
        return True

    return False


def copy_repo_snapshot(src_root: Path, dst_root: Path) -> None:
    dst_root.mkdir(parents=True, exist_ok=True)

    for dirpath, dirnames, filenames in os.walk(src_root):
        abs_dir = Path(dirpath)
        rel_dir = abs_dir.relative_to(src_root)

        # Prune excluded directories early.
        keep_dirnames: list[str] = []
        for d in dirnames:
            rel = rel_dir / d
            if not should_skip(rel):
                keep_dirnames.append(d)
        dirnames[:] = keep_dirnames

        # Ensure destination directory exists.
        (dst_root / rel_dir).mkdir(parents=True, exist_ok=True)

        for filename in filenames:
            rel = rel_dir / filename
            if should_skip(rel):
                continue
            src_file = abs_dir / filename
            dst_file = dst_root / rel
            dst_file.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(src_file, dst_file)


def write_project_file(bundle_root: Path, name: str) -> None:
    """
    Write `project.yaze` at bundle root with paths relative to bundle root.

    Note: paths in `.yaze` are relative to the directory containing the file.
    For `.yazeproj` bundles, yaze stores `project.yaze` at bundle root.
    """
    now = _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Keep this file intentionally minimal and portable. yaze will add more
    # settings as users customize the project.
    content = "\n".join(
        [
            "# yaze Project File",
            "# Format Version: 2.0",
            "# Generated by export_yazeproj_bundle.py",
            f"# Last Modified: {now}",
            "",
            "[project]",
            f"name={name}",
            "description=Oracle of Secrets ROM Hack (Zelda 3)",
            "author=",
            "license=",
            "version=2.0",
            f"created_date={now}",
            f"last_modified={now}",
            "yaze_version=",
            "created_by=export_yazeproj_bundle.py",
            "project_id=",
            "tags=",
            "",
            "[files]",
            "rom_filename=rom",
            "rom_backup_folder=backups",
            "code_folder=project",
            "assets_folder=project",
            "patches_folder=project",
            "labels_filename=",
            "symbols_filename=",
            "output_folder=project/Roms",
            "custom_objects_folder=project/Dungeons/Objects/Data",
            "hack_manifest_file=project/hack_manifest.json",
            "additional_roms=",
            "",
            "[rom]",
            "role=dev",
            "expected_hash=",
            "write_policy=warn",
            "",
            "[build]",
            # Build is typically run on macOS (or remote build host), not iOS.
            # Keep this deterministic and repo-local.
            "build_script=OOS_BASE_ROM=rom OOS_BACKUP_ROOT=backups project/scripts/build_rom.sh 168",
            "output_folder=project/Roms",
            "git_repository=project",
            "track_changes=false",
            "build_configurations=",
            "build_target=project/Roms/oos168x.sfc",
            "asm_entry_point=Oracle_main.asm",
            "asm_sources=",
            "last_build_hash=",
            "build_number=0",
            "",
            "# End of YAZE Project File",
            "",
        ]
    )
    (bundle_root / "project.yaze").write_text(content, encoding="utf-8")


def write_ios_manifest(bundle_root: Path, name: str, rom_sha1: str) -> None:
    # Matches `YazeDocumentManifest` fields (yaze iOS).
    now = iso8601_now_utc()
    manifest = {
        "version": 2,
        "name": name,
        "romChecksum": rom_sha1,
        "createdAt": now,
        "lastModifiedAt": now,
        "deviceName": platform.node() or "export",
    }
    (bundle_root / "manifest.json").write_text(
        json.dumps(manifest, indent=2, sort_keys=True) + "\n", encoding="utf-8"
    )


def refresh_planning_outputs(repo_root: Path) -> None:
    # Keep these local and deterministic: yaze reads them from
    # Docs/Dev/Planning/ via HackManifest::LoadProjectRegistry().
    scripts = [
        repo_root / "scripts" / "extract_overworld_registry.py",
        repo_root / "scripts" / "extract_resource_labels.py",
        repo_root / "scripts" / "extract_story_events.py",
    ]
    for script in scripts:
        if not script.exists():
            raise FileNotFoundError(str(script))
        subprocess.run([sys.executable, str(script)], cwd=str(repo_root), check=True)


def main() -> int:
    repo_root = find_repo_root()

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--rom",
        type=Path,
        default=None,
        help="Path to base ROM to embed (default: auto-pick Roms/oos168_test2.sfc or Roms/oos168.sfc)",
    )
    parser.add_argument(
        "--name",
        default="Oracle-of-Secrets",
        help="Bundle name (default: Oracle-of-Secrets)",
    )
    parser.add_argument(
        "--out",
        type=Path,
        default=repo_root / "build" / "yazeproj" / "Oracle-of-Secrets.yazeproj",
        help="Output bundle path (default: build/yazeproj/Oracle-of-Secrets.yazeproj)",
    )
    parser.add_argument(
        "--refresh-planning",
        action="store_true",
        default=False,
        help="Regenerate Docs/Dev/Planning/oracle_resource_labels.json + story_events.json before bundling",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Overwrite output bundle if it already exists",
    )
    args = parser.parse_args()

    rom_path: Path | None = args.rom
    if rom_path is None:
        cand = repo_root / "Roms" / "oos168_test2.sfc"
        if cand.exists():
            rom_path = cand
        else:
            cand = repo_root / "Roms" / "oos168.sfc"
            if cand.exists():
                rom_path = cand
            else:
                print(
                    "ERROR: --rom not provided and no default ROM found under Roms/",
                    file=sys.stderr,
                )
                return 2

    rom_path = rom_path.resolve()
    if not rom_path.exists():
        print(f"ERROR: ROM not found: {rom_path}", file=sys.stderr)
        return 2

    out_bundle = args.out
    if not out_bundle.is_absolute():
        out_bundle = (repo_root / out_bundle).resolve()

    if out_bundle.exists():
        if not args.force:
            print(f"ERROR: output already exists: {out_bundle}", file=sys.stderr)
            print("Pass --force to overwrite.", file=sys.stderr)
            return 2
        shutil.rmtree(out_bundle)

    if args.refresh_planning:
        refresh_planning_outputs(repo_root)

    # Create bundle layout.
    out_bundle.mkdir(parents=True, exist_ok=True)
    (out_bundle / "backups").mkdir(parents=True, exist_ok=True)
    (out_bundle / "output").mkdir(parents=True, exist_ok=True)

    # Copy ROM to bundle root as `rom` (no extension).
    rom_dst = out_bundle / "rom"
    shutil.copy2(rom_path, rom_dst)
    rom_sha1 = sha1_file(rom_dst)

    # Copy repo snapshot to bundle/project/.
    copy_repo_snapshot(repo_root, out_bundle / "project")
    # Build scripts expect a writable Roms/ folder inside the code snapshot.
    # We intentionally do not copy the repo's real Roms/ directory into the
    # bundle (too large + machine-specific), but an empty directory keeps the
    # build pipeline functional when invoked with OOS_BASE_ROM=rom.
    (out_bundle / "project" / "Roms").mkdir(parents=True, exist_ok=True)

    # Write config + metadata.
    write_project_file(out_bundle, args.name)
    write_ios_manifest(out_bundle, args.name, rom_sha1)

    print(f"Wrote bundle: {out_bundle}")
    print(f"  ROM: {rom_path} -> {rom_dst} (sha1={rom_sha1})")
    print("  Project snapshot: project/ (filtered)")
    print("  Open in yaze: File -> Open -> select the .yazeproj directory")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
