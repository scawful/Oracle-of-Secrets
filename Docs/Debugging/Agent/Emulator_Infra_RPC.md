# Emulator Infra RPC Spec (Draft)

**Date:** 2026-01-22
**Scope:** Bridge 2.0 JSON-RPC schema + capability list + selftest matrix
**Status:** Draft for review (no tests run)

---

## 0) Design Goals
- Deterministic behavior with preflight validation.
- Stable, machine-parseable responses.
- Clear capability gating for every test.
- Transport-agnostic (socket preferred, file-poll fallback).

---

## 1) Transport Layer

### 1.1 Unix Domain Socket (Preferred)
- **Path:** `/tmp/mesen2-{PID}.sock` (or `/tmp/mesen2.sock` if single instance)
- **Format:** Line-delimited JSON (`\n` separator).
- **Latency:** < 1ms
- **Ordering:** Synchronous (Request -> Response).

### 1.2 Legacy Transport (Deprecated)
- **File Poll:** `bridge/command.txt` + `bridge/response.txt`
- **HTTP:** `POST /api/bridge` (via Python Hub)

### 1.1.1 File-Poll Transport (Concrete Paths)
Default bridge root (per instance):
- `BRIDGE_DIR=~/Documents/Mesen2/bridge/<instance>`  
- If `MESEN_INSTANCE` is unset, use `default`.  
- If `MESEN_BRIDGE_DIR` is set, it overrides the above.

**Current (legacy) file-poll**:
- `command.txt` (one-line command, cleared each frame)
- `response.txt` (single response, overwritten)
- `state.json` (periodic snapshot from bridge)

**Legacy command format**:
- Plain: `CMD ARG1 ARG2 ...`
- Pipe mode: `id|CMD|ARG1|ARG2|...` (bridge responds with `id|OK|payload` or `id|ERR|message`)

**Bridge 2.0 file-poll (proposed)**:
- Requests: `requests/<id>.json`
- Responses: `responses/<id>.json`
- State snapshot: `state.json`
- Capabilities: `capabilities.json`

**Atomic write rule** (host + bridge):
- Write to `*.tmp`, `rename()` into place.

**Lifecycle**:
- Host creates request file → bridge consumes → bridge writes response file.
- Host deletes response file after read (avoid stale reads).

### 1.1.2 Artifacts & Logs (Standard Paths)
All artifacts live under `BRIDGE_DIR` unless overridden:

**State snapshot (single latest):**
- `state.json` (bridge writes each frame or on demand)

**Logs (append-only JSONL):**
- `logs/state.jsonl` (from `LOG start ...`)
- `logs/write_trace.jsonl` (from `TRACE start ...`)

**Snapshots (paired artifacts):**
- `snapshots/state_<ts>.json`
- `snapshots/screen_<ts>.png`
- `snapshots/meta_<ts>.json` (optional: rom hash, instance_id, bridge_version)

**Capabilities:**
- `capabilities.json` (generated by `bridge.selftest`)

**RPC file-poll (proposed):**
- `requests/<id>.json`
- `responses/<id>.json`

### 1.1.3 Lifecycle (File-Poll)
```
HOST                          BRIDGE
----                          ------
write requests/<id>.json  ->  read + execute
                             write responses/<id>.json
read response + delete  <-  (bridge leaves response intact)

state.json (continuous)  <-  bridge writes snapshot (atomic rename)
logs/*.jsonl (append)    <-  bridge appends when enabled
snapshots/*              <-  host triggers screen.capture + state.get
```

### 1.2 Versions
- `protocol_version`: semantic string, e.g. `"2.0"`.
- `bridge_version`: semantic string, e.g. `"0.2.0"`.

### 1.3 IDs
- `instance_id`: opaque string per emulator instance.
- `request.id`: string or integer; required for requests expecting a response.

### 1.4 Request
```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "method": "state.get",
  "params": {"paths": ["mode", "roomId"]}
}
```

### 1.5 Response (success)
```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "result": {"mode": 9, "roomId": 39}
}
```

### 1.6 Response (error)
```json
{
  "jsonrpc": "2.0",
  "id": "123",
  "error": {"code": -32010, "message": "capability_missing", "data": {"cap": "state.get"}}
}
```

### 1.7 Notifications (no response)
```json
{
  "jsonrpc": "2.0",
  "method": "log.write",
  "params": {"level": "info", "message": "Bridge ready"}
}
```

---

## 2) Standard Result Envelope
Every method returns one of:
- `result` (object)
- `error` (object)

**Result fields should be minimal, normalized, and stable.**

---

## 3) Core Methods

### 3.1 `bridge.hello`
**Purpose:** Handshake + basic metadata.

**Params:** none

**Result:**
```json
{
  "protocol_version": "2.0",
  "bridge_version": "0.2.0",
  "instance_id": "default",
  "emu": {"name": "Mesen2", "version": "2.0"},
  "rom": {"hash": "md5:...", "path": "...", "title": "..."},
  "script_hash": "sha256:...",
  "capabilities": ["state.get", "mem.read", "screen.capture"]
}
```

### 3.2 `bridge.selftest`
**Purpose:** Run capability checks; populate `capabilities.json`.

**Params:**
```json
{"level": "quick"}
```

**Result:**
```json
{
  "timestamp": "2026-01-22T12:34:56Z",
  "results": [
    {"cap": "state.get", "status": "pass"},
    {"cap": "mem.write", "status": "pass"},
    {"cap": "screen.capture", "status": "fail", "detail": "API missing"}
  ]
}
```

### 3.3 `state.get`
**Purpose:** Return normalized state values.

**Params:**
```json
{"paths": ["mode", "roomId", "link.x", "link.y"]}
```

**Result:**
```json
{"mode": 9, "roomId": 39, "link": {"x": 512, "y": 384}}
```

### 3.4 `state.keys`
**Purpose:** Enumerate supported normalized paths.

**Params:** none

**Result:**
```json
{"paths": ["mode", "submode", "indoors", "roomId", "link.x", "link.y", "frame"]}
```

### 3.5 `state.has`
**Purpose:** Probe a path.

**Params:**
```json
{"path": "link.x"}
```

**Result:**
```json
{"path": "link.x", "exists": true}
```

### 3.6 `mem.read`
**Purpose:** Read bytes from a memory domain.

**Params:**
```json
{"addr": "0x7E0000", "size": 16, "domain": "wram"}
```

**Result:**
```json
{"addr": "0x7E0000", "bytes": "A1B2C3..."}
```

### 3.7 `mem.write`
**Purpose:** Write bytes to a memory domain.

**Params:**
```json
{"addr": "0x7E0000", "bytes": "A1B2C3", "domain": "wram"}
```

**Result:**
```json
{"written": 3}
```

### 3.8 `input.press`
**Purpose:** Inject button presses.

**Params:**
```json
{"buttons": ["A", "L"], "frames": 3}
```

**Result:**
```json
{"queued": true}
```

### 3.9 `input.release`
**Purpose:** Release injected inputs.

**Params:** none

**Result:**
```json
{"released": true}
```

### 3.10 `savestate.save`
**Purpose:** Save emulator state.

**Params:**
```json
{"path": "/tmp/oos_state.mss"}
```

**Result:**
```json
{"saved": true}
```

### 3.11 `savestate.load`
**Purpose:** Load emulator state.

**Params:**
```json
{"path": "/tmp/oos_state.mss"}
```

**Result:**
```json
{"queued": true}
```

### 3.12 `savestate.sync`
**Purpose:** Notify bridge of external state save and configures watch path.

**Params:**
```json
{"path": "/tmp/oos_yaze_state.mss"}
```

**Result:**
```json
{"synced": true, "path": "...", "frame": 1234}
```

### 3.13 `savestate.status`
**Purpose:** Poll save/load progress.

**Params:** none

**Result:**
```json
{"status": "idle", "last_error": null}
```

### 3.13 `screen.capture`
**Purpose:** Capture screenshot.

**Params:**
```json
{"path": "/tmp/oos.png", "format": "png"}
```

**Result:**
```json
{"saved": true}
```

### 3.14 `emu.pause` / `emu.resume` / `emu.step`
**Purpose:** Control execution.

**Params (step):**
```json
{"frames": 1}
```

**Result:**
```json
{"paused": true}
```

### 3.15 `dbg.*` (optional)
**Purpose:** Advanced debugging (if API supports).

- `dbg.breakpoint.add` / `dbg.breakpoint.remove` / `dbg.breakpoint.list`
- `dbg.stacktrace`
- `dbg.disasm`

### 3.16 `reinit.queue`
**Purpose:** Request runtime reinit targets.

**Params:**
```json
{"targets": ["dialog", "sprites"]}
```

**Result:**
```json
{"queued": true, "seq": 12}
```

### 3.17 `reinit.status`
**Purpose:** Report reinit completion flags.

**Params:** none

**Result:**
```json
{"flags": "0x03", "status": "0x03", "error": "0x00", "seq": 12}
```

---

## 4) Normalized State Schema

Required keys (minimum viable):
- `mode` (u8)
- `submode` (u8)
- `indoors` (bool)
- `roomId` (u8)
- `link.x` (u16)
- `link.y` (u16)
- `link.dir` (u8)
- `link.state` (u8)
- `frame` (u32)

Optional keys (if available):
- `rng.seed`
- `bridge.instance_id`
- `room.entrance_id`
- `world.area_id`

---

## 5) Capability Names

Base:
- `bridge.hello`
- `bridge.selftest`
- `state.get`
- `state.keys`
- `state.has`
- `mem.read`
- `mem.write`
- `input.press`
- `input.release`
- `savestate.save`
- `savestate.load`
- `savestate.status`
- `screen.capture`
- `emu.pause`
- `emu.resume`
- `emu.step`
- `reinit.queue`
- `reinit.status`

Optional:
- `dbg.breakpoint`
- `dbg.stacktrace`
- `dbg.disasm`

---

## 6) Error Codes

- `-32010` capability_missing
- `-32011` invalid_params
- `-32012` io_error
- `-32013` not_supported
- `-32014` internal_error

---

## 7) Selftest Matrix

Each selftest result includes: `cap`, `status`, `detail`.

| Cap | Test | Notes |
| --- | ---- | ----- |
| state.get | Call and verify required keys | Fail if missing core keys |
| state.keys | Non-empty list | Must include mode + roomId |
| mem.read | Read known WRAM bytes | Check length matches |
| mem.write | Write + readback | Test buffer only |
| input.press | Queue press | No crash |
| savestate.save | Save to temp | Optional on some builds |
| savestate.load | Load temp | Optional on some builds |
| screen.capture | Create PNG | Optional if API missing |
| emu.pause/resume | Pause and resume | Optional |
| emu.step | Single-step frame | Optional |
| reinit.queue | Set flags | Requires ASM hook |
| reinit.status | Status changes | Requires ASM hook |

---

## 8) Test Metadata Contract (Host Side)
Tests must declare capabilities:
```json
{
  "name": "bridge_smoke",
  "requires": ["state.get", "mem.read", "mem.write"],
  "steps": [
    {"call": "state.get", "expect": {"mode": "any"}},
    {"call": "mem.read", "params": {"addr": "0x7E0000", "size": 4}}
  ]
}
```

---

## 9) Compatibility Notes
- **Mesen2 Lua:** Some debugger features may be unavailable.
- **Yaze/Z3ed:** Provide `state.get` + `mem.read` at minimum.
- **Fallback:** if socket not available, file-poll uses identical request/response payloads.

---

## 10) Open Decisions
- Socket implementation strategy (LuaSocket vs host-side pipe).
- Where to store per-instance `capabilities.json`.
- Which `state.get` keys are strictly required for every test.
